<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cave Explorer - 2D Platformer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        canvas {
            border: 2px solid #16213e;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <script>
        let player, key, door, platforms, enemies, spikes, room;
        let hasKey = false;
        let gameState = 'playing'; // 'playing', 'won', 'dead'
        let roomNumber = 1;
        let cameraY = 0;
        
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.w = 20;
                this.h = 20;
                this.vx = 0;
                this.vy = 0;
                this.grounded = false;
                this.speed = 4;
                this.jumpPower = -12;
                this.doubleJumpPower = -10;
                this.gravity = 0.6;
                this.maxFallSpeed = 15;
                this.color = hasKey ? color(255, 215, 0) : color(100, 200, 255);
                this.jumpsLeft = 2; // Can jump twice
                this.jumpPressed = false; // For jump buffering
            }
            
            update() {
                // Horizontal movement
                if (keyIsDown(LEFT_ARROW) || keyIsDown(65)) { // A key
                    this.vx = -this.speed;
                } else if (keyIsDown(RIGHT_ARROW) || keyIsDown(68)) { // D key
                    this.vx = this.speed;
                } else {
                    this.vx *= 0.8; // friction
                }
                
                // Jump logic with double jump
                let jumpInput = keyIsDown(UP_ARROW) || keyIsDown(87) || keyIsDown(32); // W or SPACE
                
                if (jumpInput && !this.jumpPressed && this.jumpsLeft > 0) {
                    if (this.jumpsLeft === 2) {
                        // First jump (from ground)
                        this.vy = this.jumpPower;
                    } else {
                        // Double jump (in air)
                        this.vy = this.doubleJumpPower;
                        // Create double jump particle effect
                        this.createDoubleJumpEffect();
                    }
                    this.jumpsLeft--;
                    this.grounded = false;
                }
                
                this.jumpPressed = jumpInput; // Track jump button state
                
                // Apply gravity
                this.vy += this.gravity;
                if (this.vy > this.maxFallSpeed) this.vy = this.maxFallSpeed;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Collision with platforms
                this.grounded = false;
                for (let platform of platforms) {
                    if (this.collidesWith(platform)) {
                        // Top collision (landing)
                        if (this.vy > 0 && this.y + this.h - this.vy <= platform.y) {
                            this.y = platform.y - this.h;
                            this.vy = 0;
                            this.grounded = true;
                            this.jumpsLeft = 2; // Reset jumps when landing
                        }
                        // Bottom collision (hitting ceiling)
                        else if (this.vy < 0 && this.y - this.vy >= platform.y + platform.h) {
                            this.y = platform.y + platform.h;
                            this.vy = 0;
                        }
                        // Side collisions
                        else if (this.vx > 0 && this.x + this.w - this.vx <= platform.x) {
                            this.x = platform.x - this.w;
                            this.vx = 0;
                        }
                        else if (this.vx < 0 && this.x - this.vx >= platform.x + platform.w) {
                            this.x = platform.x + platform.w;
                            this.vx = 0;
                        }
                    }
                }
                
                // Screen boundaries
                if (this.x < 0) this.x = 0;
                if (this.x + this.w > width) this.x = width - this.w;
                
                // Fall death
                if (this.y > height + 200) {
                    gameState = 'dead';
                }
                
                // Update color based on key status
                this.color = hasKey ? color(255, 215, 0) : color(100, 200, 255);
            }
            
            createDoubleJumpEffect() {
                // Add some visual particles for double jump
                // This creates a brief visual indicator
                this.doubleJumpEffectTimer = 10;
            }
            
            collidesWith(obj) {
                return this.x < obj.x + obj.w &&
                       this.x + this.w > obj.x &&
                       this.y < obj.y + obj.h &&
                       this.y + this.h > obj.y;
            }
            
            draw() {
                push();
                translate(0, -cameraY);
                
                // Player glow effect
                drawingContext.shadowColor = hasKey ? '#FFD700' : '#64C8FF';
                drawingContext.shadowBlur = 15;
                
                fill(this.color);
                noStroke();
                rect(this.x, this.y, this.w, this.h, 3);
                
                // Eyes
                fill(255);
                circle(this.x + 6, this.y + 7, 4);
                circle(this.x + 14, this.y + 7, 4);
                fill(0);
                circle(this.x + 6, this.y + 7, 2);
                circle(this.x + 14, this.y + 7, 2);
                
                drawingContext.shadowBlur = 0;
                pop();
            }
        }
        
        class Enemy {
            constructor(x, y, w, h, type) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.vx = random(1, 3) * (random() > 0.5 ? 1 : -1);
                this.vy = 0;
                this.type = type;
                this.startX = x;
                this.range = random(80, 150);
                this.color = type === 'patrol' ? color(255, 100, 100) : color(255, 150, 50);
            }
            
            update() {
                if (this.type === 'patrol') {
                    // Patrol enemy - moves back and forth
                    this.x += this.vx;
                    if (this.x <= this.startX - this.range || this.x >= this.startX + this.range) {
                        this.vx *= -1;
                    }
                    
                    // Platform collision for patrol enemies
                    for (let platform of platforms) {
                        if (this.collidesWith(platform)) {
                            if (this.vy > 0 && this.y + this.h - this.vy <= platform.y) {
                                this.y = platform.y - this.h;
                                this.vy = 0;
                            }
                        }
                    }
                    
                    this.vy += 0.5; // light gravity
                    this.y += this.vy;
                } else if (this.type === 'floater') {
                    // Floating enemy - moves in sine wave
                    this.x += this.vx;
                    this.y += sin(frameCount * 0.05 + this.startX * 0.01) * 2;
                    
                    if (this.x <= 0 || this.x >= width - this.w) {
                        this.vx *= -1;
                    }
                }
            }
            
            collidesWith(obj) {
                return this.x < obj.x + obj.w &&
                       this.x + this.w > obj.x &&
                       this.y < obj.y + obj.h &&
                       this.y + this.h > obj.y;
            }
            
            draw() {
                push();
                translate(0, -cameraY);
                
                // Enemy glow
                drawingContext.shadowColor = this.type === 'patrol' ? '#FF6464' : '#FF9632';
                drawingContext.shadowBlur = 10;
                
                fill(this.color);
                noStroke();
                if (this.type === 'patrol') {
                    rect(this.x, this.y, this.w, this.h, 2);
                    // Spikes on top
                    fill(150, 50, 50);
                    for (let i = 0; i < this.w; i += 8) {
                        triangle(this.x + i, this.y, this.x + i + 4, this.y - 5, this.x + i + 8, this.y);
                    }
                } else {
                    ellipse(this.x + this.w/2, this.y + this.h/2, this.w, this.h);
                    // Tentacles
                    stroke(this.color);
                    strokeWeight(2);
                    for (let i = 0; i < 3; i++) {
                        let tentacleX = this.x + this.w/2 + (i - 1) * 8;
                        let tentacleY = this.y + this.h;
                        let waveOffset = sin(frameCount * 0.1 + i) * 5;
                        line(tentacleX, tentacleY, tentacleX + waveOffset, tentacleY + 15);
                    }
                }
                
                drawingContext.shadowBlur = 0;
                pop();
            }
        }
        
        class Spike {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
            }
            
            draw() {
                push();
                translate(0, -cameraY);
                
                drawingContext.shadowColor = '#FF4444';
                drawingContext.shadowBlur = 5;
                
                fill(200, 50, 50);
                noStroke();
                
                // Draw spikes
                for (let i = 0; i < this.w; i += 15) {
                    triangle(this.x + i, this.y + this.h, 
                            this.x + i + 7.5, this.y, 
                            this.x + i + 15, this.y + this.h);
                }
                
                drawingContext.shadowBlur = 0;
                pop();
            }
            
            collidesWith(obj) {
                return this.x < obj.x + obj.w &&
                       this.x + this.w > obj.x &&
                       this.y < obj.y + obj.h &&
                       this.y + this.h > obj.y;
            }
        }
        
        function setup() {
            createCanvas(800, 600);
            generateRoom();
        }
        
        function generateRoom() {
            platforms = [];
            enemies = [];
            spikes = [];
            hasKey = false;
            gameState = 'playing';
            
            // Create connected platform layout
            generateConnectedPlatforms();
            
            // Create player starting position on ground
            player = new Player(50, height - 65);
            
            // Find reachable platforms from player position
            let reachablePlatforms = findReachablePlatforms();
            
            // Place key on a reachable platform (not ground)
            let keyPlatformIndex = floor(random(1, reachablePlatforms.length));
            let keyPlatform = reachablePlatforms[keyPlatformIndex];
            key = {
                x: keyPlatform.x + random(10, keyPlatform.w - 30),
                y: keyPlatform.y - 25,
                w: 15,
                h: 15,
                collected: false,
                angle: 0
            };
            
            // Place door on a different reachable platform
            let doorPlatformIndex = floor(random(1, reachablePlatforms.length));
            while (doorPlatformIndex === keyPlatformIndex && reachablePlatforms.length > 2) {
                doorPlatformIndex = floor(random(1, reachablePlatforms.length));
            }
            let doorPlatform = reachablePlatforms[doorPlatformIndex];
            door = {
                x: doorPlatform.x + doorPlatform.w - 30,
                y: doorPlatform.y - 40,
                w: 25,
                h: 40
            };
            
            // Create enemies on reachable platforms
            for (let i = 0; i < random(3, 6); i++) {
                let enemyPlatformIndex = floor(random(0, reachablePlatforms.length));
                let enemyPlatform = reachablePlatforms[enemyPlatformIndex];
                if (dist(enemyPlatform.x, enemyPlatform.y, player.x, player.y) > 150) {
                    let enemyType = random(['patrol', 'floater']);
                    enemies.push(new Enemy(
                        enemyPlatform.x + random(20, max(20, enemyPlatform.w - 40)),
                        enemyPlatform.y - 25,
                        20, 20, enemyType
                    ));
                }
            }
            
            // Create spikes on some reachable platforms
            for (let i = 0; i < random(2, 4); i++) {
                let spikePlatformIndex = floor(random(0, reachablePlatforms.length));
                let spikePlatform = reachablePlatforms[spikePlatformIndex];
                if (dist(spikePlatform.x, spikePlatform.y, player.x, player.y) > 100 && 
                    spikePlatform.w > 60) {
                    spikes.push(new Spike(
                        spikePlatform.x + random(0, spikePlatform.w - 60),
                        spikePlatform.y - 15,
                        60, 15
                    ));
                }
            }
            
            cameraY = 0;
        }
        
        function generateConnectedPlatforms() {
            // Start with ground platform
            platforms.push({x: 0, y: height - 40, w: width, h: 40});
            
            // Create a path of connected platforms
            let currentX = random(50, 150);
            let currentY = height - 100;
            
            // Generate main path platforms
            for (let i = 0; i < random(6, 10); i++) {
                let platformWidth = random(100, 200);
                
                // Ensure platform doesn't go off screen
                if (currentX + platformWidth > width) {
                    currentX = width - platformWidth;
                }
                
                platforms.push({x: currentX, y: currentY, w: platformWidth, h: 20});
                
                // Move to next platform position with guaranteed reachability
                let jumpDistance = random(80, 150); // Within jump range
                let jumpHeight = random(-80, -40); // Upward progression mostly
                
                currentX += jumpDistance;
                currentY += jumpHeight;
                
                // Keep platforms within reasonable bounds
                currentY = constrain(currentY, 80, height - 150);
                
                // Wrap around screen if needed
                if (currentX > width - 100) {
                    currentX = random(50, 150);
                    currentY -= random(60, 100); // Go higher when wrapping
                }
            }
            
            // Add some branching platforms for variety
            for (let i = 0; i < random(3, 6); i++) {
                let basePlatform = platforms[floor(random(1, platforms.length))];
                
                // Create branch platform within jumping distance
                let branchX = basePlatform.x + random(-120, 120);
                let branchY = basePlatform.y + random(-80, 40);
                let branchWidth = random(80, 150);
                
                // Keep within screen bounds
                branchX = constrain(branchX, 0, width - branchWidth);
                branchY = constrain(branchY, 80, height - 60);
                
                platforms.push({x: branchX, y: branchY, w: branchWidth, h: 20});
            }
            
            // Add a few vertical platforms for extra connectivity
            for (let i = 0; i < random(1, 3); i++) {
                let basePlatform = platforms[floor(random(1, platforms.length))];
                let wallX = random() > 0.5 ? basePlatform.x - 25 : basePlatform.x + basePlatform.w + 5;
                let wallY = basePlatform.y - random(60, 120);
                let wallHeight = random(80, 140);
                
                wallX = constrain(wallX, 20, width - 40);
                
                platforms.push({x: wallX, y: wallY, w: 20, h: wallHeight});
            }
        }
        
        function findReachablePlatforms() {
            let reachable = [platforms[0]]; // Start with ground platform
            let maxJumpHeight = 120; // Player's maximum jump reach
            let maxJumpDistance = 140; // Player's maximum horizontal jump reach
            
            let changed = true;
            while (changed) {
                changed = false;
                for (let platform of platforms) {
                    if (reachable.includes(platform)) continue;
                    
                    // Check if this platform is reachable from any already reachable platform
                    for (let reachablePlatform of reachable) {
                        let horizontalDistance = abs(platform.x - reachablePlatform.x);
                        let verticalDistance = reachablePlatform.y - platform.y; // Negative if platform is higher
                        
                        // Can jump to this platform?
                        if (horizontalDistance <= maxJumpDistance && 
                            verticalDistance <= maxJumpHeight && 
                            verticalDistance >= -50) { // Can fall down too
                            reachable.push(platform);
                            changed = true;
                            break;
                        }
                        
                        // Can jump from this platform to a reachable one? (bidirectional)
                        horizontalDistance = abs(reachablePlatform.x - platform.x);
                        verticalDistance = platform.y - reachablePlatform.y;
                        
                        if (horizontalDistance <= maxJumpDistance && 
                            verticalDistance <= maxJumpHeight && 
                            verticalDistance >= -50) {
                            reachable.push(platform);
                            changed = true;
                            break;
                        }
                    }
                }
            }
            
            return reachable;
        }
        
        function draw() {
            background(20, 20, 40);
            
            // Update camera to follow player
            let targetCameraY = player.y - height/2;
            cameraY = lerp(cameraY, targetCameraY, 0.05);
            
            if (gameState === 'playing') {
                // Update game objects
                player.update();
                
                for (let enemy of enemies) {
                    enemy.update();
                    if (enemy.collidesWith(player)) {
                        gameState = 'dead';
                    }
                }
                
                // Check spike collisions
                for (let spike of spikes) {
                    if (spike.collidesWith(player)) {
                        gameState = 'dead';
                    }
                }
                
                // Check key collection
                if (!key.collected && player.collidesWith(key)) {
                    key.collected = true;
                    hasKey = true;
                }
                
                // Check door collision
                if (hasKey && player.collidesWith(door)) {
                    gameState = 'won';
                }
            }
            
            // Draw everything
            drawPlatforms();
            drawSpikes();
            drawEnemies();
            drawKey();
            drawDoor();
            player.draw();
            drawUI();
            
            // Draw game state messages
            if (gameState === 'won') {
                drawWinScreen();
            } else if (gameState === 'dead') {
                drawDeathScreen();
            }
        }
        
        function drawPlatforms() {
            push();
            translate(0, -cameraY);
            
            for (let platform of platforms) {
                // Platform gradient
                drawingContext.shadowColor = '#4A90E2';
                drawingContext.shadowBlur = 3;
                
                fill(80, 90, 120);
                stroke(120, 130, 160);
                strokeWeight(1);
                rect(platform.x, platform.y, platform.w, platform.h, 2);
                
                // Platform highlight
                fill(100, 110, 140, 150);
                rect(platform.x, platform.y, platform.w, 3, 2);
            }
            
            drawingContext.shadowBlur = 0;
            pop();
        }
        
        function drawSpikes() {
            for (let spike of spikes) {
                spike.draw();
            }
        }
        
        function drawEnemies() {
            for (let enemy of enemies) {
                enemy.draw();
            }
        }
        
        function drawKey() {
            if (!key.collected) {
                push();
                translate(0, -cameraY);
                
                key.angle += 0.05;
                
                drawingContext.shadowColor = '#FFD700';
                drawingContext.shadowBlur = 20;
                
                push();
                translate(key.x + key.w/2, key.y + key.h/2 + sin(frameCount * 0.1) * 3);
                rotate(key.angle);
                
                fill(255, 215, 0);
                noStroke();
                rect(-key.w/2, -key.h/2, key.w, key.h, 2);
                
                // Key teeth
                fill(255, 215, 0);
                rect(key.w/2 - 2, -3, 5, 3);
                rect(key.w/2 - 2, 1, 3, 2);
                
                // Key hole
                fill(20, 20, 40);
                circle(-key.w/4, 0, 4);
                
                pop();
                drawingContext.shadowBlur = 0;
                pop();
            }
        }
        
        function drawDoor() {
            push();
            translate(0, -cameraY);
            
            let doorColor = hasKey ? color(100, 255, 100) : color(150, 100, 100);
            drawingContext.shadowColor = hasKey ? '#64FF64' : '#966464';
            drawingContext.shadowBlur = hasKey ? 15 : 5;
            
            fill(doorColor);
            stroke(hasKey ? color(150, 255, 150) : color(100, 70, 70));
            strokeWeight(2);
            rect(door.x, door.y, door.w, door.h, 3);
            
            // Door handle
            fill(200, 180, 100);
            circle(door.x + door.w - 8, door.y + door.h/2, 4);
            
            drawingContext.shadowBlur = 0;
            pop();
        }
        
        function drawUI() {
            // Instructions
            fill(255, 255, 255, 200);
            textAlign(LEFT);
            textSize(14);
            text("ARROW KEYS or WASD: Move & Jump", 10, 25);
            text("Collect the KEY and reach the DOOR!", 10, 45);
            text(`Room: ${roomNumber}`, 10, 65);
            
            if (hasKey) {
                fill(255, 215, 0);
                text("KEY COLLECTED! Find the door!", 10, 85);
            }
            
            // Health/lives indicator
            fill(255, 100, 100);
            textAlign(RIGHT);
            text("Avoid red enemies and spikes!", width - 10, 25);
        }
        
        function drawWinScreen() {
            fill(0, 0, 0, 150);
            rect(0, 0, width, height);
            
            fill(100, 255, 100);
            textAlign(CENTER);
            textSize(32);
            text("ROOM COMPLETE!", width/2, height/2 - 20);
            
            fill(255);
            textSize(18);
            text("Press SPACE for next room", width/2, height/2 + 20);
        }
        
        function drawDeathScreen() {
            fill(0, 0, 0, 150);
            rect(0, 0, width, height);
            
            fill(255, 100, 100);
            textAlign(CENTER);
            textSize(32);
            text("GAME OVER", width/2, height/2 - 20);
            
            fill(255);
            textSize(18);
            text("Press SPACE to restart", width/2, height/2 + 20);
        }
        
        function keyPressed() {
            if (keyCode === 32) { // Space bar
                if (gameState === 'won') {
                    roomNumber++;
                    generateRoom();
                } else if (gameState === 'dead') {
                    roomNumber = 1;
                    generateRoom();
                }
            }
        }
        
        Player.prototype.collidesWith = function(obj) {
            return this.x < obj.x + obj.w &&
                   this.x + this.w > obj.x &&
                   this.y < obj.y + obj.h &&
                   this.y + this.h > obj.y;
        };
    </script>
</body>
</html>